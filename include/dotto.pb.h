// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: src/dotto.proto

#ifndef PROTOBUF_INCLUDED_src_2fdotto_2eproto
#define PROTOBUF_INCLUDED_src_2fdotto_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_src_2fdotto_2eproto 

namespace protobuf_src_2fdotto_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_src_2fdotto_2eproto
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class SongMap;
class SongMapDefaultTypeInternal;
extern SongMapDefaultTypeInternal _SongMap_default_instance_;
class SongMap_Config;
class SongMap_ConfigDefaultTypeInternal;
extern SongMap_ConfigDefaultTypeInternal _SongMap_Config_default_instance_;
class SongMap_Element;
class SongMap_ElementDefaultTypeInternal;
extern SongMap_ElementDefaultTypeInternal _SongMap_Element_default_instance_;
namespace google {
namespace protobuf {
template<> ::Point* Arena::CreateMaybeMessage<::Point>(Arena*);
template<> ::SongMap* Arena::CreateMaybeMessage<::SongMap>(Arena*);
template<> ::SongMap_Config* Arena::CreateMaybeMessage<::SongMap_Config>(Arena*);
template<> ::SongMap_Element* Arena::CreateMaybeMessage<::SongMap_Element>(Arena*);
}  // namespace protobuf
}  // namespace google

enum SongMap_Element_Tween {
  SongMap_Element_Tween_LINEAR = 0,
  SongMap_Element_Tween_SERPENT = 1,
  SongMap_Element_Tween_PARABOLIC = 2,
  SongMap_Element_Tween_SongMap_Element_Tween_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SongMap_Element_Tween_SongMap_Element_Tween_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SongMap_Element_Tween_IsValid(int value);
const SongMap_Element_Tween SongMap_Element_Tween_Tween_MIN = SongMap_Element_Tween_LINEAR;
const SongMap_Element_Tween SongMap_Element_Tween_Tween_MAX = SongMap_Element_Tween_PARABOLIC;
const int SongMap_Element_Tween_Tween_ARRAYSIZE = SongMap_Element_Tween_Tween_MAX + 1;

const ::google::protobuf::EnumDescriptor* SongMap_Element_Tween_descriptor();
inline const ::std::string& SongMap_Element_Tween_Name(SongMap_Element_Tween value) {
  return ::google::protobuf::internal::NameOfEnum(
    SongMap_Element_Tween_descriptor(), value);
}
inline bool SongMap_Element_Tween_Parse(
    const ::std::string& name, SongMap_Element_Tween* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SongMap_Element_Tween>(
    SongMap_Element_Tween_descriptor(), name, value);
}
enum SongMap_Element_Etype {
  SongMap_Element_Etype_DT_NOTE = 0,
  SongMap_Element_Etype_SLID_NOTE = 1,
  SongMap_Element_Etype_POS = 2,
  SongMap_Element_Etype_SongMap_Element_Etype_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SongMap_Element_Etype_SongMap_Element_Etype_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SongMap_Element_Etype_IsValid(int value);
const SongMap_Element_Etype SongMap_Element_Etype_Etype_MIN = SongMap_Element_Etype_DT_NOTE;
const SongMap_Element_Etype SongMap_Element_Etype_Etype_MAX = SongMap_Element_Etype_POS;
const int SongMap_Element_Etype_Etype_ARRAYSIZE = SongMap_Element_Etype_Etype_MAX + 1;

const ::google::protobuf::EnumDescriptor* SongMap_Element_Etype_descriptor();
inline const ::std::string& SongMap_Element_Etype_Name(SongMap_Element_Etype value) {
  return ::google::protobuf::internal::NameOfEnum(
    SongMap_Element_Etype_descriptor(), value);
}
inline bool SongMap_Element_Etype_Parse(
    const ::std::string& name, SongMap_Element_Etype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SongMap_Element_Etype>(
    SongMap_Element_Etype_descriptor(), name, value);
}
// ===================================================================

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(Point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Point* other);
  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const final {
    return CreateMaybeMessage<Point>(NULL);
  }

  Point* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // int32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Point)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_src_2fdotto_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SongMap_Config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SongMap.Config) */ {
 public:
  SongMap_Config();
  virtual ~SongMap_Config();

  SongMap_Config(const SongMap_Config& from);

  inline SongMap_Config& operator=(const SongMap_Config& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SongMap_Config(SongMap_Config&& from) noexcept
    : SongMap_Config() {
    *this = ::std::move(from);
  }

  inline SongMap_Config& operator=(SongMap_Config&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SongMap_Config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SongMap_Config* internal_default_instance() {
    return reinterpret_cast<const SongMap_Config*>(
               &_SongMap_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SongMap_Config* other);
  friend void swap(SongMap_Config& a, SongMap_Config& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SongMap_Config* New() const final {
    return CreateMaybeMessage<SongMap_Config>(NULL);
  }

  SongMap_Config* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SongMap_Config>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SongMap_Config& from);
  void MergeFrom(const SongMap_Config& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SongMap_Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int32 timestamp() const;
  void set_timestamp(::google::protobuf::int32 value);

  // int32 speed = 2;
  void clear_speed();
  static const int kSpeedFieldNumber = 2;
  ::google::protobuf::int32 speed() const;
  void set_speed(::google::protobuf::int32 value);

  // int32 time_to_press = 3;
  void clear_time_to_press();
  static const int kTimeToPressFieldNumber = 3;
  ::google::protobuf::int32 time_to_press() const;
  void set_time_to_press(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SongMap.Config)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 timestamp_;
  ::google::protobuf::int32 speed_;
  ::google::protobuf::int32 time_to_press_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_src_2fdotto_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SongMap_Element : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SongMap.Element) */ {
 public:
  SongMap_Element();
  virtual ~SongMap_Element();

  SongMap_Element(const SongMap_Element& from);

  inline SongMap_Element& operator=(const SongMap_Element& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SongMap_Element(SongMap_Element&& from) noexcept
    : SongMap_Element() {
    *this = ::std::move(from);
  }

  inline SongMap_Element& operator=(SongMap_Element&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SongMap_Element& default_instance();

  enum DataCase {
    kLocation = 3,
    kTransition = 4,
    DATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SongMap_Element* internal_default_instance() {
    return reinterpret_cast<const SongMap_Element*>(
               &_SongMap_Element_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SongMap_Element* other);
  friend void swap(SongMap_Element& a, SongMap_Element& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SongMap_Element* New() const final {
    return CreateMaybeMessage<SongMap_Element>(NULL);
  }

  SongMap_Element* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SongMap_Element>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SongMap_Element& from);
  void MergeFrom(const SongMap_Element& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SongMap_Element* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SongMap_Element_Tween Tween;
  static const Tween LINEAR =
    SongMap_Element_Tween_LINEAR;
  static const Tween SERPENT =
    SongMap_Element_Tween_SERPENT;
  static const Tween PARABOLIC =
    SongMap_Element_Tween_PARABOLIC;
  static inline bool Tween_IsValid(int value) {
    return SongMap_Element_Tween_IsValid(value);
  }
  static const Tween Tween_MIN =
    SongMap_Element_Tween_Tween_MIN;
  static const Tween Tween_MAX =
    SongMap_Element_Tween_Tween_MAX;
  static const int Tween_ARRAYSIZE =
    SongMap_Element_Tween_Tween_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Tween_descriptor() {
    return SongMap_Element_Tween_descriptor();
  }
  static inline const ::std::string& Tween_Name(Tween value) {
    return SongMap_Element_Tween_Name(value);
  }
  static inline bool Tween_Parse(const ::std::string& name,
      Tween* value) {
    return SongMap_Element_Tween_Parse(name, value);
  }

  typedef SongMap_Element_Etype Etype;
  static const Etype DT_NOTE =
    SongMap_Element_Etype_DT_NOTE;
  static const Etype SLID_NOTE =
    SongMap_Element_Etype_SLID_NOTE;
  static const Etype POS =
    SongMap_Element_Etype_POS;
  static inline bool Etype_IsValid(int value) {
    return SongMap_Element_Etype_IsValid(value);
  }
  static const Etype Etype_MIN =
    SongMap_Element_Etype_Etype_MIN;
  static const Etype Etype_MAX =
    SongMap_Element_Etype_Etype_MAX;
  static const int Etype_ARRAYSIZE =
    SongMap_Element_Etype_Etype_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Etype_descriptor() {
    return SongMap_Element_Etype_descriptor();
  }
  static inline const ::std::string& Etype_Name(Etype value) {
    return SongMap_Element_Etype_Name(value);
  }
  static inline bool Etype_Parse(const ::std::string& name,
      Etype* value) {
    return SongMap_Element_Etype_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .SongMap.Element.Etype elem_type = 1;
  void clear_elem_type();
  static const int kElemTypeFieldNumber = 1;
  ::SongMap_Element_Etype elem_type() const;
  void set_elem_type(::SongMap_Element_Etype value);

  // int32 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int32 timestamp() const;
  void set_timestamp(::google::protobuf::int32 value);

  // .Point location = 3;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 3;
  private:
  const ::Point& _internal_location() const;
  public:
  const ::Point& location() const;
  ::Point* release_location();
  ::Point* mutable_location();
  void set_allocated_location(::Point* location);

  // .SongMap.Element.Tween transition = 4;
  private:
  bool has_transition() const;
  public:
  void clear_transition();
  static const int kTransitionFieldNumber = 4;
  ::SongMap_Element_Tween transition() const;
  void set_transition(::SongMap_Element_Tween value);

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:SongMap.Element)
 private:
  void set_has_location();
  void set_has_transition();

  inline bool has_data() const;
  inline void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int elem_type_;
  ::google::protobuf::int32 timestamp_;
  union DataUnion {
    DataUnion() {}
    ::Point* location_;
    int transition_;
  } data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_src_2fdotto_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SongMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SongMap) */ {
 public:
  SongMap();
  virtual ~SongMap();

  SongMap(const SongMap& from);

  inline SongMap& operator=(const SongMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SongMap(SongMap&& from) noexcept
    : SongMap() {
    *this = ::std::move(from);
  }

  inline SongMap& operator=(SongMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SongMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SongMap* internal_default_instance() {
    return reinterpret_cast<const SongMap*>(
               &_SongMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SongMap* other);
  friend void swap(SongMap& a, SongMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SongMap* New() const final {
    return CreateMaybeMessage<SongMap>(NULL);
  }

  SongMap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SongMap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SongMap& from);
  void MergeFrom(const SongMap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SongMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SongMap_Config Config;
  typedef SongMap_Element Element;

  // accessors -------------------------------------------------------

  // repeated string mapper = 5;
  int mapper_size() const;
  void clear_mapper();
  static const int kMapperFieldNumber = 5;
  const ::std::string& mapper(int index) const;
  ::std::string* mutable_mapper(int index);
  void set_mapper(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_mapper(int index, ::std::string&& value);
  #endif
  void set_mapper(int index, const char* value);
  void set_mapper(int index, const char* value, size_t size);
  ::std::string* add_mapper();
  void add_mapper(const ::std::string& value);
  #if LANG_CXX11
  void add_mapper(::std::string&& value);
  #endif
  void add_mapper(const char* value);
  void add_mapper(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& mapper() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mapper();

  // repeated string producer = 6;
  int producer_size() const;
  void clear_producer();
  static const int kProducerFieldNumber = 6;
  const ::std::string& producer(int index) const;
  ::std::string* mutable_producer(int index);
  void set_producer(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_producer(int index, ::std::string&& value);
  #endif
  void set_producer(int index, const char* value);
  void set_producer(int index, const char* value, size_t size);
  ::std::string* add_producer();
  void add_producer(const ::std::string& value);
  #if LANG_CXX11
  void add_producer(::std::string&& value);
  #endif
  void add_producer(const char* value);
  void add_producer(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& producer() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_producer();

  // repeated .SongMap.Config configs = 7;
  int configs_size() const;
  void clear_configs();
  static const int kConfigsFieldNumber = 7;
  ::SongMap_Config* mutable_configs(int index);
  ::google::protobuf::RepeatedPtrField< ::SongMap_Config >*
      mutable_configs();
  const ::SongMap_Config& configs(int index) const;
  ::SongMap_Config* add_configs();
  const ::google::protobuf::RepeatedPtrField< ::SongMap_Config >&
      configs() const;

  // repeated .SongMap.Element elements = 8;
  int elements_size() const;
  void clear_elements();
  static const int kElementsFieldNumber = 8;
  ::SongMap_Element* mutable_elements(int index);
  ::google::protobuf::RepeatedPtrField< ::SongMap_Element >*
      mutable_elements();
  const ::SongMap_Element& elements(int index) const;
  ::SongMap_Element* add_elements();
  const ::google::protobuf::RepeatedPtrField< ::SongMap_Element >&
      elements() const;

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int32 start_time = 3;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  ::google::protobuf::int32 start_time() const;
  void set_start_time(::google::protobuf::int32 value);

  // int32 difficulty = 4;
  void clear_difficulty();
  static const int kDifficultyFieldNumber = 4;
  ::google::protobuf::int32 difficulty() const;
  void set_difficulty(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SongMap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mapper_;
  ::google::protobuf::RepeatedPtrField< ::std::string> producer_;
  ::google::protobuf::RepeatedPtrField< ::SongMap_Config > configs_;
  ::google::protobuf::RepeatedPtrField< ::SongMap_Element > elements_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 start_time_;
  ::google::protobuf::int32 difficulty_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_src_2fdotto_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point

// int32 x = 1;
inline void Point::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 Point::x() const {
  // @@protoc_insertion_point(field_get:Point.x)
  return x_;
}
inline void Point::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Point.x)
}

// int32 y = 2;
inline void Point::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 Point::y() const {
  // @@protoc_insertion_point(field_get:Point.y)
  return y_;
}
inline void Point::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Point.y)
}

// -------------------------------------------------------------------

// SongMap_Config

// int32 timestamp = 1;
inline void SongMap_Config::clear_timestamp() {
  timestamp_ = 0;
}
inline ::google::protobuf::int32 SongMap_Config::timestamp() const {
  // @@protoc_insertion_point(field_get:SongMap.Config.timestamp)
  return timestamp_;
}
inline void SongMap_Config::set_timestamp(::google::protobuf::int32 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:SongMap.Config.timestamp)
}

// int32 speed = 2;
inline void SongMap_Config::clear_speed() {
  speed_ = 0;
}
inline ::google::protobuf::int32 SongMap_Config::speed() const {
  // @@protoc_insertion_point(field_get:SongMap.Config.speed)
  return speed_;
}
inline void SongMap_Config::set_speed(::google::protobuf::int32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:SongMap.Config.speed)
}

// int32 time_to_press = 3;
inline void SongMap_Config::clear_time_to_press() {
  time_to_press_ = 0;
}
inline ::google::protobuf::int32 SongMap_Config::time_to_press() const {
  // @@protoc_insertion_point(field_get:SongMap.Config.time_to_press)
  return time_to_press_;
}
inline void SongMap_Config::set_time_to_press(::google::protobuf::int32 value) {
  
  time_to_press_ = value;
  // @@protoc_insertion_point(field_set:SongMap.Config.time_to_press)
}

// -------------------------------------------------------------------

// SongMap_Element

// .SongMap.Element.Etype elem_type = 1;
inline void SongMap_Element::clear_elem_type() {
  elem_type_ = 0;
}
inline ::SongMap_Element_Etype SongMap_Element::elem_type() const {
  // @@protoc_insertion_point(field_get:SongMap.Element.elem_type)
  return static_cast< ::SongMap_Element_Etype >(elem_type_);
}
inline void SongMap_Element::set_elem_type(::SongMap_Element_Etype value) {
  
  elem_type_ = value;
  // @@protoc_insertion_point(field_set:SongMap.Element.elem_type)
}

// int32 timestamp = 2;
inline void SongMap_Element::clear_timestamp() {
  timestamp_ = 0;
}
inline ::google::protobuf::int32 SongMap_Element::timestamp() const {
  // @@protoc_insertion_point(field_get:SongMap.Element.timestamp)
  return timestamp_;
}
inline void SongMap_Element::set_timestamp(::google::protobuf::int32 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:SongMap.Element.timestamp)
}

// .Point location = 3;
inline bool SongMap_Element::has_location() const {
  return data_case() == kLocation;
}
inline void SongMap_Element::set_has_location() {
  _oneof_case_[0] = kLocation;
}
inline void SongMap_Element::clear_location() {
  if (has_location()) {
    delete data_.location_;
    clear_has_data();
  }
}
inline const ::Point& SongMap_Element::_internal_location() const {
  return *data_.location_;
}
inline ::Point* SongMap_Element::release_location() {
  // @@protoc_insertion_point(field_release:SongMap.Element.location)
  if (has_location()) {
    clear_has_data();
      ::Point* temp = data_.location_;
    data_.location_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Point& SongMap_Element::location() const {
  // @@protoc_insertion_point(field_get:SongMap.Element.location)
  return has_location()
      ? *data_.location_
      : *reinterpret_cast< ::Point*>(&::_Point_default_instance_);
}
inline ::Point* SongMap_Element::mutable_location() {
  if (!has_location()) {
    clear_data();
    set_has_location();
    data_.location_ = CreateMaybeMessage< ::Point >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SongMap.Element.location)
  return data_.location_;
}

// .SongMap.Element.Tween transition = 4;
inline bool SongMap_Element::has_transition() const {
  return data_case() == kTransition;
}
inline void SongMap_Element::set_has_transition() {
  _oneof_case_[0] = kTransition;
}
inline void SongMap_Element::clear_transition() {
  if (has_transition()) {
    data_.transition_ = 0;
    clear_has_data();
  }
}
inline ::SongMap_Element_Tween SongMap_Element::transition() const {
  // @@protoc_insertion_point(field_get:SongMap.Element.transition)
  if (has_transition()) {
    return static_cast< ::SongMap_Element_Tween >(data_.transition_);
  }
  return static_cast< ::SongMap_Element_Tween >(0);
}
inline void SongMap_Element::set_transition(::SongMap_Element_Tween value) {
  if (!has_transition()) {
    clear_data();
    set_has_transition();
  }
  data_.transition_ = value;
  // @@protoc_insertion_point(field_set:SongMap.Element.transition)
}

inline bool SongMap_Element::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void SongMap_Element::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline SongMap_Element::DataCase SongMap_Element::data_case() const {
  return SongMap_Element::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SongMap

// string id = 1;
inline void SongMap::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SongMap::id() const {
  // @@protoc_insertion_point(field_get:SongMap.id)
  return id_.GetNoArena();
}
inline void SongMap::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SongMap.id)
}
#if LANG_CXX11
inline void SongMap::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SongMap.id)
}
#endif
inline void SongMap::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SongMap.id)
}
inline void SongMap::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SongMap.id)
}
inline ::std::string* SongMap::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:SongMap.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SongMap::release_id() {
  // @@protoc_insertion_point(field_release:SongMap.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SongMap::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:SongMap.id)
}

// string name = 2;
inline void SongMap::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SongMap::name() const {
  // @@protoc_insertion_point(field_get:SongMap.name)
  return name_.GetNoArena();
}
inline void SongMap::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SongMap.name)
}
#if LANG_CXX11
inline void SongMap::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SongMap.name)
}
#endif
inline void SongMap::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SongMap.name)
}
inline void SongMap::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SongMap.name)
}
inline ::std::string* SongMap::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:SongMap.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SongMap::release_name() {
  // @@protoc_insertion_point(field_release:SongMap.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SongMap::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:SongMap.name)
}

// int32 start_time = 3;
inline void SongMap::clear_start_time() {
  start_time_ = 0;
}
inline ::google::protobuf::int32 SongMap::start_time() const {
  // @@protoc_insertion_point(field_get:SongMap.start_time)
  return start_time_;
}
inline void SongMap::set_start_time(::google::protobuf::int32 value) {
  
  start_time_ = value;
  // @@protoc_insertion_point(field_set:SongMap.start_time)
}

// int32 difficulty = 4;
inline void SongMap::clear_difficulty() {
  difficulty_ = 0;
}
inline ::google::protobuf::int32 SongMap::difficulty() const {
  // @@protoc_insertion_point(field_get:SongMap.difficulty)
  return difficulty_;
}
inline void SongMap::set_difficulty(::google::protobuf::int32 value) {
  
  difficulty_ = value;
  // @@protoc_insertion_point(field_set:SongMap.difficulty)
}

// repeated string mapper = 5;
inline int SongMap::mapper_size() const {
  return mapper_.size();
}
inline void SongMap::clear_mapper() {
  mapper_.Clear();
}
inline const ::std::string& SongMap::mapper(int index) const {
  // @@protoc_insertion_point(field_get:SongMap.mapper)
  return mapper_.Get(index);
}
inline ::std::string* SongMap::mutable_mapper(int index) {
  // @@protoc_insertion_point(field_mutable:SongMap.mapper)
  return mapper_.Mutable(index);
}
inline void SongMap::set_mapper(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SongMap.mapper)
  mapper_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SongMap::set_mapper(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:SongMap.mapper)
  mapper_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SongMap::set_mapper(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  mapper_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SongMap.mapper)
}
inline void SongMap::set_mapper(int index, const char* value, size_t size) {
  mapper_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SongMap.mapper)
}
inline ::std::string* SongMap::add_mapper() {
  // @@protoc_insertion_point(field_add_mutable:SongMap.mapper)
  return mapper_.Add();
}
inline void SongMap::add_mapper(const ::std::string& value) {
  mapper_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SongMap.mapper)
}
#if LANG_CXX11
inline void SongMap::add_mapper(::std::string&& value) {
  mapper_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SongMap.mapper)
}
#endif
inline void SongMap::add_mapper(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  mapper_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SongMap.mapper)
}
inline void SongMap::add_mapper(const char* value, size_t size) {
  mapper_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SongMap.mapper)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SongMap::mapper() const {
  // @@protoc_insertion_point(field_list:SongMap.mapper)
  return mapper_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SongMap::mutable_mapper() {
  // @@protoc_insertion_point(field_mutable_list:SongMap.mapper)
  return &mapper_;
}

// repeated string producer = 6;
inline int SongMap::producer_size() const {
  return producer_.size();
}
inline void SongMap::clear_producer() {
  producer_.Clear();
}
inline const ::std::string& SongMap::producer(int index) const {
  // @@protoc_insertion_point(field_get:SongMap.producer)
  return producer_.Get(index);
}
inline ::std::string* SongMap::mutable_producer(int index) {
  // @@protoc_insertion_point(field_mutable:SongMap.producer)
  return producer_.Mutable(index);
}
inline void SongMap::set_producer(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SongMap.producer)
  producer_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SongMap::set_producer(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:SongMap.producer)
  producer_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SongMap::set_producer(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  producer_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SongMap.producer)
}
inline void SongMap::set_producer(int index, const char* value, size_t size) {
  producer_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SongMap.producer)
}
inline ::std::string* SongMap::add_producer() {
  // @@protoc_insertion_point(field_add_mutable:SongMap.producer)
  return producer_.Add();
}
inline void SongMap::add_producer(const ::std::string& value) {
  producer_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SongMap.producer)
}
#if LANG_CXX11
inline void SongMap::add_producer(::std::string&& value) {
  producer_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SongMap.producer)
}
#endif
inline void SongMap::add_producer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  producer_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SongMap.producer)
}
inline void SongMap::add_producer(const char* value, size_t size) {
  producer_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SongMap.producer)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SongMap::producer() const {
  // @@protoc_insertion_point(field_list:SongMap.producer)
  return producer_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SongMap::mutable_producer() {
  // @@protoc_insertion_point(field_mutable_list:SongMap.producer)
  return &producer_;
}

// repeated .SongMap.Config configs = 7;
inline int SongMap::configs_size() const {
  return configs_.size();
}
inline void SongMap::clear_configs() {
  configs_.Clear();
}
inline ::SongMap_Config* SongMap::mutable_configs(int index) {
  // @@protoc_insertion_point(field_mutable:SongMap.configs)
  return configs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SongMap_Config >*
SongMap::mutable_configs() {
  // @@protoc_insertion_point(field_mutable_list:SongMap.configs)
  return &configs_;
}
inline const ::SongMap_Config& SongMap::configs(int index) const {
  // @@protoc_insertion_point(field_get:SongMap.configs)
  return configs_.Get(index);
}
inline ::SongMap_Config* SongMap::add_configs() {
  // @@protoc_insertion_point(field_add:SongMap.configs)
  return configs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SongMap_Config >&
SongMap::configs() const {
  // @@protoc_insertion_point(field_list:SongMap.configs)
  return configs_;
}

// repeated .SongMap.Element elements = 8;
inline int SongMap::elements_size() const {
  return elements_.size();
}
inline void SongMap::clear_elements() {
  elements_.Clear();
}
inline ::SongMap_Element* SongMap::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:SongMap.elements)
  return elements_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SongMap_Element >*
SongMap::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:SongMap.elements)
  return &elements_;
}
inline const ::SongMap_Element& SongMap::elements(int index) const {
  // @@protoc_insertion_point(field_get:SongMap.elements)
  return elements_.Get(index);
}
inline ::SongMap_Element* SongMap::add_elements() {
  // @@protoc_insertion_point(field_add:SongMap.elements)
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SongMap_Element >&
SongMap::elements() const {
  // @@protoc_insertion_point(field_list:SongMap.elements)
  return elements_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::SongMap_Element_Tween> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SongMap_Element_Tween>() {
  return ::SongMap_Element_Tween_descriptor();
}
template <> struct is_proto_enum< ::SongMap_Element_Etype> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SongMap_Element_Etype>() {
  return ::SongMap_Element_Etype_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_src_2fdotto_2eproto
